{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport UTFSequence from \"../../UTFSequence\";\nimport stringifySafe from \"../../Utilities/stringifySafe\";\nimport parseErrorStack from \"../../Core/Devtools/parseErrorStack\";\nvar BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nvar BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*):? (?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)(\\/(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+?)\\n([ >]{2}[\\t-\\r 0-9\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+ \\|(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|\\x1B(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*) \\(([0-9]+):([0-9]+)\\)\\n\\n((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar SUBSTITUTION = UTFSequence.BOM + '%s';\nexport function parseInterpolation(args) {\n  var categoryParts = [];\n  var contentParts = [];\n  var substitutionOffsets = [];\n\n  var remaining = _toConsumableArray(args);\n\n  if (typeof remaining[0] === 'string') {\n    var formatString = String(remaining.shift());\n    var formatStringParts = formatString.split('%s');\n    var substitutionCount = formatStringParts.length - 1;\n    var substitutions = remaining.splice(0, substitutionCount);\n    var categoryString = '';\n    var contentString = '';\n    var substitutionIndex = 0;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(formatStringParts), _step; !(_step = _iterator()).done;) {\n      var formatStringPart = _step.value;\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          var substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length\n          });\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length\n          });\n          categoryString += '%s';\n          contentString += '%s';\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  var remainingArgs = remaining.map(function (arg) {\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push.apply(categoryParts, _toConsumableArray(remainingArgs));\n  contentParts.push.apply(contentParts, _toConsumableArray(remainingArgs));\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets\n    }\n  };\n}\n\nfunction isComponentStack(consoleArgument) {\n  var isOldComponentStackFormat = / {4}in/.test(consoleArgument);\n  var isNewComponentStackFormat = / {4}at/.test(consoleArgument);\n  var isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\n  return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;\n}\n\nexport function parseComponentStack(message) {\n  var stack = parseErrorStack(message);\n\n  if (stack && stack.length > 0) {\n    return stack.map(function (frame) {\n      return {\n        content: frame.methodName,\n        collapse: frame.collapse || false,\n        fileName: frame.file == null ? 'unknown' : frame.file,\n        location: {\n          column: frame.column == null ? -1 : frame.column,\n          row: frame.lineNumber == null ? -1 : frame.lineNumber\n        }\n      };\n    });\n  }\n\n  return message.split(/\\n {4}in /g).map(function (s) {\n    if (!s) {\n      return null;\n    }\n\n    var match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n\n    if (!match) {\n      return null;\n    }\n\n    var _match$slice = match.slice(1),\n        _match$slice2 = _slicedToArray(_match$slice, 3),\n        content = _match$slice2[0],\n        fileName = _match$slice2[1],\n        row = _match$slice2[2];\n\n    return {\n      content: content,\n      fileName: fileName,\n      location: {\n        column: -1,\n        row: parseInt(row, 10)\n      }\n    };\n  }).filter(Boolean);\n}\nexport function parseLogBoxException(error) {\n  var message = error.originalMessage != null ? error.originalMessage : 'Unknown';\n  var metroInternalError = message.match(METRO_ERROR_FORMAT);\n\n  if (metroInternalError) {\n    var _metroInternalError$s = metroInternalError.slice(1),\n        _metroInternalError$s2 = _slicedToArray(_metroInternalError$s, 5),\n        content = _metroInternalError$s2[0],\n        fileName = _metroInternalError$s2[1],\n        row = _metroInternalError$s2[2],\n        column = _metroInternalError$s2[3],\n        codeFrame = _metroInternalError$s2[4];\n\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10)\n        },\n        content: codeFrame\n      },\n      message: {\n        content: content,\n        substitutions: []\n      },\n      category: fileName + \"-\" + row + \"-\" + column\n    };\n  }\n\n  var babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n\n  if (babelTransformError) {\n    var _babelTransformError$ = babelTransformError.slice(1),\n        _babelTransformError$2 = _slicedToArray(_babelTransformError$, 5),\n        _fileName = _babelTransformError$2[0],\n        _content = _babelTransformError$2[1],\n        _row = _babelTransformError$2[2],\n        _column = _babelTransformError$2[3],\n        _codeFrame = _babelTransformError$2[4];\n\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName,\n        location: {\n          row: parseInt(_row, 10),\n          column: parseInt(_column, 10)\n        },\n        content: _codeFrame\n      },\n      message: {\n        content: _content,\n        substitutions: []\n      },\n      category: _fileName + \"-\" + _row + \"-\" + _column\n    };\n  }\n\n  var babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n\n  if (babelCodeFrameError) {\n    var _babelCodeFrameError$ = babelCodeFrameError.slice(1),\n        _babelCodeFrameError$2 = _slicedToArray(_babelCodeFrameError$, 3),\n        _fileName2 = _babelCodeFrameError$2[0],\n        _content2 = _babelCodeFrameError$2[1],\n        _codeFrame2 = _babelCodeFrameError$2[2];\n\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName2,\n        location: null,\n        content: _codeFrame2\n      },\n      message: {\n        content: _content2,\n        substitutions: []\n      },\n      category: _fileName2 + \"-\" + 1 + \"-\" + 1\n    };\n  }\n\n  if (message.match(/^TransformError /)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: []\n      },\n      category: message\n    };\n  }\n\n  var componentStack = error.componentStack;\n\n  if (error.isFatal || error.isComponentError) {\n    return _objectSpread({\n      level: 'fatal',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: componentStack != null ? parseComponentStack(componentStack) : []\n    }, parseInterpolation([message]));\n  }\n\n  if (componentStack != null) {\n    return _objectSpread({\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack)\n    }, parseInterpolation([message]));\n  }\n\n  return _objectSpread({\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError\n  }, parseLogBoxLog([message]));\n}\nexport function parseLogBoxLog(args) {\n  var message = args[0];\n  var argsWithoutComponentStack = [];\n  var componentStack = [];\n\n  if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {\n    var lastArg = args[args.length - 1];\n\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n\n  if (componentStack.length === 0) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(args), _step2; !(_step2 = _iterator2()).done;) {\n      var arg = _step2.value;\n\n      if (typeof arg === 'string' && isComponentStack(arg)) {\n        var messageEndIndex = arg.search(/\\n {4}(in|at) /);\n\n        if (messageEndIndex < 0) {\n          messageEndIndex = arg.search(/\\n/);\n        }\n\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return _objectSpread(_objectSpread({}, parseInterpolation(argsWithoutComponentStack)), {}, {\n    componentStack: componentStack\n  });\n}","map":{"version":3,"sources":["C:/Users/kisho/Downloads/phonestly-app-Google-pay/phonestly-app-Google-pay/node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js"],"names":["UTFSequence","stringifySafe","parseErrorStack","BABEL_TRANSFORM_ERROR_FORMAT","BABEL_CODE_FRAME_ERROR_FORMAT","METRO_ERROR_FORMAT","SUBSTITUTION","BOM","parseInterpolation","args","categoryParts","contentParts","substitutionOffsets","remaining","formatString","String","shift","formatStringParts","split","substitutionCount","length","substitutions","splice","categoryString","contentString","substitutionIndex","formatStringPart","substitution","push","offset","remainingArgs","map","arg","category","join","message","content","isComponentStack","consoleArgument","isOldComponentStackFormat","test","isNewComponentStackFormat","isNewJSCComponentStackFormat","parseComponentStack","stack","frame","methodName","collapse","fileName","file","location","column","row","lineNumber","s","match","slice","parseInt","filter","Boolean","parseLogBoxException","error","originalMessage","metroInternalError","codeFrame","level","type","isComponentError","componentStack","babelTransformError","babelCodeFrameError","isFatal","parseLogBoxLog","argsWithoutComponentStack","lastArg","messageEndIndex","search"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport UTFSequence from '../../UTFSequence';\nimport stringifySafe from '../../Utilities/stringifySafe';\nimport type {ExceptionData} from '../../Core/NativeExceptionsManager';\nimport type {LogBoxLogData} from './LogBoxLog';\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\n\nconst BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nconst BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*):? (?:.*?)(\\/.*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\nconst METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/u;\n\nexport type ExtendedExceptionData = ExceptionData & {\n  isComponentError: boolean,\n  ...\n};\nexport type Category = string;\nexport type CodeFrame = $ReadOnly<{|\n  content: string,\n  location: ?{\n    row: number,\n    column: number,\n    ...\n  },\n  fileName: string,\n\n  // TODO: When React switched to using call stack frames,\n  // we gained the ability to use the collapse flag, but\n  // it is not integrated into the LogBox UI.\n  collapse?: boolean,\n|}>;\nexport type Message = $ReadOnly<{|\n  content: string,\n  substitutions: $ReadOnlyArray<\n    $ReadOnly<{|\n      length: number,\n      offset: number,\n    |}>,\n  >,\n|}>;\n\nexport type ComponentStack = $ReadOnlyArray<CodeFrame>;\n\nconst SUBSTITUTION = UTFSequence.BOM + '%s';\n\nexport function parseInterpolation(\n  args: $ReadOnlyArray<mixed>,\n): $ReadOnly<{|\n  category: Category,\n  message: Message,\n|}> {\n  const categoryParts = [];\n  const contentParts = [];\n  const substitutionOffsets = [];\n\n  const remaining = [...args];\n  if (typeof remaining[0] === 'string') {\n    const formatString = String(remaining.shift());\n    const formatStringParts = formatString.split('%s');\n    const substitutionCount = formatStringParts.length - 1;\n    const substitutions = remaining.splice(0, substitutionCount);\n\n    let categoryString = '';\n    let contentString = '';\n\n    let substitutionIndex = 0;\n    for (const formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          // Don't stringify a string type.\n          // It adds quotation mark wrappers around the string,\n          // which causes the LogBox to look odd.\n          const substitution =\n            typeof substitutions[substitutionIndex] === 'string'\n              ? substitutions[substitutionIndex]\n              : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length,\n          });\n\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length,\n          });\n\n          categoryString += '%s';\n          contentString += '%s';\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  const remainingArgs = remaining.map(arg => {\n    // Don't stringify a string type.\n    // It adds quotation mark wrappers around the string,\n    // which causes the LogBox to look odd.\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push(...remainingArgs);\n  contentParts.push(...remainingArgs);\n\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets,\n    },\n  };\n}\n\nfunction isComponentStack(consoleArgument: string) {\n  const isOldComponentStackFormat = / {4}in/.test(consoleArgument);\n  const isNewComponentStackFormat = / {4}at/.test(consoleArgument);\n  const isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\n\n  return (\n    isOldComponentStackFormat ||\n    isNewComponentStackFormat ||\n    isNewJSCComponentStackFormat\n  );\n}\n\nexport function parseComponentStack(message: string): ComponentStack {\n  // In newer versions of React, the component stack is formatted as a call stack frame.\n  // First try to parse the component stack as a call stack frame, and if that doesn't\n  // work then we'll fallback to the old custom component stack format parsing.\n  const stack = parseErrorStack(message);\n  if (stack && stack.length > 0) {\n    return stack.map(frame => ({\n      content: frame.methodName,\n      collapse: frame.collapse || false,\n      fileName: frame.file == null ? 'unknown' : frame.file,\n      location: {\n        column: frame.column == null ? -1 : frame.column,\n        row: frame.lineNumber == null ? -1 : frame.lineNumber,\n      },\n    }));\n  }\n\n  return message\n    .split(/\\n {4}in /g)\n    .map(s => {\n      if (!s) {\n        return null;\n      }\n      const match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n      if (!match) {\n        return null;\n      }\n\n      let [content, fileName, row] = match.slice(1);\n      return {\n        content,\n        fileName,\n        location: {column: -1, row: parseInt(row, 10)},\n      };\n    })\n    .filter(Boolean);\n}\n\nexport function parseLogBoxException(\n  error: ExtendedExceptionData,\n): LogBoxLogData {\n  const message =\n    error.originalMessage != null ? error.originalMessage : 'Unknown';\n\n  const metroInternalError = message.match(METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    const [\n      content,\n      fileName,\n      row,\n      column,\n      codeFrame,\n    ] = metroInternalError.slice(1);\n\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    // Transform errors are thrown from inside the Babel transformer.\n    const [\n      fileName,\n      content,\n      row,\n      column,\n      codeFrame,\n    ] = babelTransformError.slice(1);\n\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n\n  if (babelCodeFrameError) {\n    // Codeframe errors are thrown from any use of buildCodeFrameError.\n    const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: null, // We are not given the location.\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${1}-${1}`,\n    };\n  }\n\n  if (message.match(/^TransformError /)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: [],\n      },\n      category: message,\n    };\n  }\n\n  const componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    return {\n      level: 'fatal',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack:\n        componentStack != null ? parseComponentStack(componentStack) : [],\n      ...parseInterpolation([message]),\n    };\n  }\n\n  if (componentStack != null) {\n    // It is possible that console errors have a componentStack.\n    return {\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack),\n      ...parseInterpolation([message]),\n    };\n  }\n\n  // Most `console.error` calls won't have a componentStack. We parse them like\n  // regular logs which have the component stack burried in the message.\n  return {\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError,\n    ...parseLogBoxLog([message]),\n  };\n}\n\nexport function parseLogBoxLog(\n  args: $ReadOnlyArray<mixed>,\n): {|\n  componentStack: ComponentStack,\n  category: Category,\n  message: Message,\n|} {\n  const message = args[0];\n  let argsWithoutComponentStack = [];\n  let componentStack = [];\n\n  // Extract component stack from warnings like \"Some warning%s\".\n  if (\n    typeof message === 'string' &&\n    message.slice(-2) === '%s' &&\n    args.length > 0\n  ) {\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n\n  if (componentStack.length === 0) {\n    // Try finding the component stack elsewhere.\n    for (const arg of args) {\n      if (typeof arg === 'string' && isComponentStack(arg)) {\n        // Strip out any messages before the component stack.\n        let messageEndIndex = arg.search(/\\n {4}(in|at) /);\n        if (messageEndIndex < 0) {\n          // Handle JSC component stacks.\n          messageEndIndex = arg.search(/\\n/);\n        }\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return {\n    ...parseInterpolation(argsWithoutComponentStack),\n    componentStack,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}