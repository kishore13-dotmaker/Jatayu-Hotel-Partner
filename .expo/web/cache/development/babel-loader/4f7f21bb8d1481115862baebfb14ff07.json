{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"@babel/runtime/helpers/get\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar BlobManager = require(\"../Blob/BlobManager\");\n\nvar EventTarget = require('event-target-shim');\n\nvar GlobalPerformanceLogger = require(\"../Utilities/GlobalPerformanceLogger\");\n\nvar RCTNetworking = require(\"./RCTNetworking\");\n\nvar base64 = require('base64-js');\n\nvar invariant = require('invariant');\n\nvar DEBUG_NETWORK_SEND_DELAY = false;\n\nif (BlobManager.isAvailable) {\n  BlobManager.addNetworkingHandler();\n}\n\nvar UNSENT = 0;\nvar OPENED = 1;\nvar HEADERS_RECEIVED = 2;\nvar LOADING = 3;\nvar DONE = 4;\nvar SUPPORTED_RESPONSE_TYPES = {\n  arraybuffer: typeof global.ArrayBuffer === 'function',\n  blob: typeof global.Blob === 'function',\n  document: false,\n  json: true,\n  text: true,\n  '': true\n};\nvar REQUEST_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend'];\nvar XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');\n\nvar XMLHttpRequestEventTarget = function (_ref) {\n  _inherits(XMLHttpRequestEventTarget, _ref);\n\n  var _super = _createSuper(XMLHttpRequestEventTarget);\n\n  function XMLHttpRequestEventTarget() {\n    _classCallCheck(this, XMLHttpRequestEventTarget);\n\n    return _super.apply(this, arguments);\n  }\n\n  return XMLHttpRequestEventTarget;\n}(EventTarget.apply(void 0, REQUEST_EVENTS));\n\nvar XMLHttpRequest = function (_ref2) {\n  _inherits(XMLHttpRequest, _ref2);\n\n  var _super2 = _createSuper(XMLHttpRequest);\n\n  function XMLHttpRequest() {\n    var _this;\n\n    _classCallCheck(this, XMLHttpRequest);\n\n    _this = _super2.call(this);\n    _this.UNSENT = UNSENT;\n    _this.OPENED = OPENED;\n    _this.HEADERS_RECEIVED = HEADERS_RECEIVED;\n    _this.LOADING = LOADING;\n    _this.DONE = DONE;\n    _this.readyState = UNSENT;\n    _this.status = 0;\n    _this.timeout = 0;\n    _this.withCredentials = true;\n    _this.upload = new XMLHttpRequestEventTarget();\n    _this._aborted = false;\n    _this._hasError = false;\n    _this._method = null;\n    _this._perfKey = null;\n    _this._response = '';\n    _this._url = null;\n    _this._timedOut = false;\n    _this._trackingName = 'unknown';\n    _this._incrementalEvents = false;\n    _this._performanceLogger = GlobalPerformanceLogger;\n\n    _this._reset();\n\n    return _this;\n  }\n\n  _createClass(XMLHttpRequest, [{\n    key: \"_reset\",\n    value: function _reset() {\n      this.readyState = this.UNSENT;\n      this.responseHeaders = undefined;\n      this.status = 0;\n      delete this.responseURL;\n      this._requestId = null;\n      this._cachedResponse = undefined;\n      this._hasError = false;\n      this._headers = {};\n      this._response = '';\n      this._responseType = '';\n      this._sent = false;\n      this._lowerCaseResponseHeaders = {};\n\n      this._clearSubscriptions();\n\n      this._timedOut = false;\n    }\n  }, {\n    key: \"responseType\",\n    get: function get() {\n      return this._responseType;\n    },\n    set: function set(responseType) {\n      if (this._sent) {\n        throw new Error(\"Failed to set the 'responseType' property on 'XMLHttpRequest': The \" + 'response type cannot be set after the request has been sent.');\n      }\n\n      if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {\n        console.warn(\"The provided value '\" + responseType + \"' is not a valid 'responseType'.\");\n        return;\n      }\n\n      invariant(SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document', \"The provided value '\" + responseType + \"' is unsupported in this environment.\");\n\n      if (responseType === 'blob') {\n        invariant(BlobManager.isAvailable, 'Native module BlobModule is required for blob support');\n      }\n\n      this._responseType = responseType;\n    }\n  }, {\n    key: \"responseText\",\n    get: function get() {\n      if (this._responseType !== '' && this._responseType !== 'text') {\n        throw new Error(\"The 'responseText' property is only available if 'responseType' \" + (\"is set to '' or 'text', but it is '\" + this._responseType + \"'.\"));\n      }\n\n      if (this.readyState < LOADING) {\n        return '';\n      }\n\n      return this._response;\n    }\n  }, {\n    key: \"response\",\n    get: function get() {\n      var responseType = this.responseType;\n\n      if (responseType === '' || responseType === 'text') {\n        return this.readyState < LOADING || this._hasError ? '' : this._response;\n      }\n\n      if (this.readyState !== DONE) {\n        return null;\n      }\n\n      if (this._cachedResponse !== undefined) {\n        return this._cachedResponse;\n      }\n\n      switch (responseType) {\n        case 'document':\n          this._cachedResponse = null;\n          break;\n\n        case 'arraybuffer':\n          this._cachedResponse = base64.toByteArray(this._response).buffer;\n          break;\n\n        case 'blob':\n          if (typeof this._response === 'object' && this._response) {\n            this._cachedResponse = BlobManager.createFromOptions(this._response);\n          } else if (this._response === '') {\n            this._cachedResponse = BlobManager.createFromParts([]);\n          } else {\n            throw new Error(\"Invalid response for blob: \" + this._response);\n          }\n\n          break;\n\n        case 'json':\n          try {\n            this._cachedResponse = JSON.parse(this._response);\n          } catch (_) {\n            this._cachedResponse = null;\n          }\n\n          break;\n\n        default:\n          this._cachedResponse = null;\n      }\n\n      return this._cachedResponse;\n    }\n  }, {\n    key: \"__didCreateRequest\",\n    value: function __didCreateRequest(requestId) {\n      this._requestId = requestId;\n      XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.requestSent(requestId, this._url || '', this._method || 'GET', this._headers);\n    }\n  }, {\n    key: \"__didUploadProgress\",\n    value: function __didUploadProgress(requestId, progress, total) {\n      if (requestId === this._requestId) {\n        this.upload.dispatchEvent({\n          type: 'progress',\n          lengthComputable: true,\n          loaded: progress,\n          total: total\n        });\n      }\n    }\n  }, {\n    key: \"__didReceiveResponse\",\n    value: function __didReceiveResponse(requestId, status, responseHeaders, responseURL) {\n      if (requestId === this._requestId) {\n        this._perfKey != null && this._performanceLogger.stopTimespan(this._perfKey);\n        this.status = status;\n        this.setResponseHeaders(responseHeaders);\n        this.setReadyState(this.HEADERS_RECEIVED);\n\n        if (responseURL || responseURL === '') {\n          this.responseURL = responseURL;\n        } else {\n          delete this.responseURL;\n        }\n\n        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.responseReceived(requestId, responseURL || this._url || '', status, responseHeaders || {});\n      }\n    }\n  }, {\n    key: \"__didReceiveData\",\n    value: function __didReceiveData(requestId, response) {\n      if (requestId !== this._requestId) {\n        return;\n      }\n\n      this._response = response;\n      this._cachedResponse = undefined;\n      this.setReadyState(this.LOADING);\n      XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, response);\n    }\n  }, {\n    key: \"__didReceiveIncrementalData\",\n    value: function __didReceiveIncrementalData(requestId, responseText, progress, total) {\n      if (requestId !== this._requestId) {\n        return;\n      }\n\n      if (!this._response) {\n        this._response = responseText;\n      } else {\n        this._response += responseText;\n      }\n\n      XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, responseText);\n      this.setReadyState(this.LOADING);\n\n      this.__didReceiveDataProgress(requestId, progress, total);\n    }\n  }, {\n    key: \"__didReceiveDataProgress\",\n    value: function __didReceiveDataProgress(requestId, loaded, total) {\n      if (requestId !== this._requestId) {\n        return;\n      }\n\n      this.dispatchEvent({\n        type: 'progress',\n        lengthComputable: total >= 0,\n        loaded: loaded,\n        total: total\n      });\n    }\n  }, {\n    key: \"__didCompleteResponse\",\n    value: function __didCompleteResponse(requestId, error, timeOutError) {\n      if (requestId === this._requestId) {\n        if (error) {\n          if (this._responseType === '' || this._responseType === 'text') {\n            this._response = error;\n          }\n\n          this._hasError = true;\n\n          if (timeOutError) {\n            this._timedOut = true;\n          }\n        }\n\n        this._clearSubscriptions();\n\n        this._requestId = null;\n        this.setReadyState(this.DONE);\n\n        if (error) {\n          XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFailed(requestId, error);\n        } else {\n          XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFinished(requestId, this._response.length);\n        }\n      }\n    }\n  }, {\n    key: \"_clearSubscriptions\",\n    value: function _clearSubscriptions() {\n      (this._subscriptions || []).forEach(function (sub) {\n        if (sub) {\n          sub.remove();\n        }\n      });\n      this._subscriptions = [];\n    }\n  }, {\n    key: \"getAllResponseHeaders\",\n    value: function getAllResponseHeaders() {\n      if (!this.responseHeaders) {\n        return null;\n      }\n\n      var headers = this.responseHeaders || {};\n      return Object.keys(headers).map(function (headerName) {\n        return headerName + ': ' + headers[headerName];\n      }).join('\\r\\n');\n    }\n  }, {\n    key: \"getResponseHeader\",\n    value: function getResponseHeader(header) {\n      var value = this._lowerCaseResponseHeaders[header.toLowerCase()];\n\n      return value !== undefined ? value : null;\n    }\n  }, {\n    key: \"setRequestHeader\",\n    value: function setRequestHeader(header, value) {\n      if (this.readyState !== this.OPENED) {\n        throw new Error('Request has not been opened');\n      }\n\n      this._headers[header.toLowerCase()] = String(value);\n    }\n  }, {\n    key: \"setTrackingName\",\n    value: function setTrackingName(trackingName) {\n      this._trackingName = trackingName;\n      return this;\n    }\n  }, {\n    key: \"setPerformanceLogger\",\n    value: function setPerformanceLogger(performanceLogger) {\n      this._performanceLogger = performanceLogger;\n      return this;\n    }\n  }, {\n    key: \"open\",\n    value: function open(method, url, async) {\n      if (this.readyState !== this.UNSENT) {\n        throw new Error('Cannot open, already sending');\n      }\n\n      if (async !== undefined && !async) {\n        throw new Error('Synchronous http requests are not supported');\n      }\n\n      if (!url) {\n        throw new Error('Cannot load an empty url');\n      }\n\n      this._method = method.toUpperCase();\n      this._url = url;\n      this._aborted = false;\n      this.setReadyState(this.OPENED);\n    }\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      var _this2 = this;\n\n      if (this.readyState !== this.OPENED) {\n        throw new Error('Request has not been opened');\n      }\n\n      if (this._sent) {\n        throw new Error('Request has already been sent');\n      }\n\n      this._sent = true;\n      var incrementalEvents = this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;\n\n      this._subscriptions.push(RCTNetworking.addListener('didSendNetworkData', function (args) {\n        return _this2.__didUploadProgress.apply(_this2, _toConsumableArray(args));\n      }));\n\n      this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkResponse', function (args) {\n        return _this2.__didReceiveResponse.apply(_this2, _toConsumableArray(args));\n      }));\n\n      this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkData', function (args) {\n        return _this2.__didReceiveData.apply(_this2, _toConsumableArray(args));\n      }));\n\n      this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkIncrementalData', function (args) {\n        return _this2.__didReceiveIncrementalData.apply(_this2, _toConsumableArray(args));\n      }));\n\n      this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkDataProgress', function (args) {\n        return _this2.__didReceiveDataProgress.apply(_this2, _toConsumableArray(args));\n      }));\n\n      this._subscriptions.push(RCTNetworking.addListener('didCompleteNetworkResponse', function (args) {\n        return _this2.__didCompleteResponse.apply(_this2, _toConsumableArray(args));\n      }));\n\n      var nativeResponseType = 'text';\n\n      if (this._responseType === 'arraybuffer') {\n        nativeResponseType = 'base64';\n      }\n\n      if (this._responseType === 'blob') {\n        nativeResponseType = 'blob';\n      }\n\n      var doSend = function doSend() {\n        var friendlyName = _this2._trackingName !== 'unknown' ? _this2._trackingName : _this2._url;\n        _this2._perfKey = 'network_XMLHttpRequest_' + String(friendlyName);\n\n        _this2._performanceLogger.startTimespan(_this2._perfKey);\n\n        invariant(_this2._method, 'XMLHttpRequest method needs to be defined (%s).', friendlyName);\n        invariant(_this2._url, 'XMLHttpRequest URL needs to be defined (%s).', friendlyName);\n        RCTNetworking.sendRequest(_this2._method, _this2._trackingName, _this2._url, _this2._headers, data, nativeResponseType, incrementalEvents, _this2.timeout, _this2.__didCreateRequest.bind(_this2), _this2.withCredentials);\n      };\n\n      if (DEBUG_NETWORK_SEND_DELAY) {\n        setTimeout(doSend, DEBUG_NETWORK_SEND_DELAY);\n      } else {\n        doSend();\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._aborted = true;\n\n      if (this._requestId) {\n        RCTNetworking.abortRequest(this._requestId);\n      }\n\n      if (!(this.readyState === this.UNSENT || this.readyState === this.OPENED && !this._sent || this.readyState === this.DONE)) {\n        this._reset();\n\n        this.setReadyState(this.DONE);\n      }\n\n      this._reset();\n    }\n  }, {\n    key: \"setResponseHeaders\",\n    value: function setResponseHeaders(responseHeaders) {\n      this.responseHeaders = responseHeaders || null;\n      var headers = responseHeaders || {};\n      this._lowerCaseResponseHeaders = Object.keys(headers).reduce(function (lcaseHeaders, headerName) {\n        lcaseHeaders[headerName.toLowerCase()] = headers[headerName];\n        return lcaseHeaders;\n      }, {});\n    }\n  }, {\n    key: \"setReadyState\",\n    value: function setReadyState(newState) {\n      this.readyState = newState;\n      this.dispatchEvent({\n        type: 'readystatechange'\n      });\n\n      if (newState === this.DONE) {\n        if (this._aborted) {\n          this.dispatchEvent({\n            type: 'abort'\n          });\n        } else if (this._hasError) {\n          if (this._timedOut) {\n            this.dispatchEvent({\n              type: 'timeout'\n            });\n          } else {\n            this.dispatchEvent({\n              type: 'error'\n            });\n          }\n        } else {\n          this.dispatchEvent({\n            type: 'load'\n          });\n        }\n\n        this.dispatchEvent({\n          type: 'loadend'\n        });\n      }\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener) {\n      if (type === 'readystatechange' || type === 'progress') {\n        this._incrementalEvents = true;\n      }\n\n      _get(_getPrototypeOf(XMLHttpRequest.prototype), \"addEventListener\", this).call(this, type, listener);\n    }\n  }], [{\n    key: \"setInterceptor\",\n    value: function setInterceptor(interceptor) {\n      XMLHttpRequest._interceptor = interceptor;\n    }\n  }]);\n\n  return XMLHttpRequest;\n}(EventTarget.apply(void 0, _toConsumableArray(XHR_EVENTS)));\n\nXMLHttpRequest.UNSENT = UNSENT;\nXMLHttpRequest.OPENED = OPENED;\nXMLHttpRequest.HEADERS_RECEIVED = HEADERS_RECEIVED;\nXMLHttpRequest.LOADING = LOADING;\nXMLHttpRequest.DONE = DONE;\nXMLHttpRequest._interceptor = null;\nmodule.exports = XMLHttpRequest;","map":{"version":3,"sources":["C:/Users/kisho/Downloads/phonestly-app-Google-pay/phonestly-app-Google-pay/node_modules/react-native/Libraries/Network/XMLHttpRequest.js"],"names":["BlobManager","require","EventTarget","GlobalPerformanceLogger","RCTNetworking","base64","invariant","DEBUG_NETWORK_SEND_DELAY","isAvailable","addNetworkingHandler","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","SUPPORTED_RESPONSE_TYPES","arraybuffer","global","ArrayBuffer","blob","Blob","document","json","text","REQUEST_EVENTS","XHR_EVENTS","concat","XMLHttpRequestEventTarget","XMLHttpRequest","readyState","status","timeout","withCredentials","upload","_aborted","_hasError","_method","_perfKey","_response","_url","_timedOut","_trackingName","_incrementalEvents","_performanceLogger","_reset","responseHeaders","undefined","responseURL","_requestId","_cachedResponse","_headers","_responseType","_sent","_lowerCaseResponseHeaders","_clearSubscriptions","responseType","Error","hasOwnProperty","console","warn","toByteArray","buffer","createFromOptions","createFromParts","JSON","parse","_","requestId","_interceptor","requestSent","progress","total","dispatchEvent","type","lengthComputable","loaded","stopTimespan","setResponseHeaders","setReadyState","responseReceived","response","dataReceived","responseText","__didReceiveDataProgress","error","timeOutError","loadingFailed","loadingFinished","length","_subscriptions","forEach","sub","remove","headers","Object","keys","map","headerName","join","header","value","toLowerCase","String","trackingName","performanceLogger","method","url","async","toUpperCase","data","incrementalEvents","onreadystatechange","onprogress","push","addListener","args","__didUploadProgress","__didReceiveResponse","__didReceiveData","__didReceiveIncrementalData","__didCompleteResponse","nativeResponseType","doSend","friendlyName","startTimespan","sendRequest","__didCreateRequest","bind","setTimeout","abortRequest","reduce","lcaseHeaders","newState","listener","interceptor","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport type {IPerformanceLogger} from '../Utilities/createPerformanceLogger';\n\nconst BlobManager = require('../Blob/BlobManager');\nconst EventTarget = require('event-target-shim');\nconst GlobalPerformanceLogger = require('../Utilities/GlobalPerformanceLogger');\nconst RCTNetworking = require('./RCTNetworking');\n\nconst base64 = require('base64-js');\nconst invariant = require('invariant');\n\nconst DEBUG_NETWORK_SEND_DELAY: false = false; // Set to a number of milliseconds when debugging\n\nexport type NativeResponseType = 'base64' | 'blob' | 'text';\nexport type ResponseType =\n  | ''\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'text';\nexport type Response = ?Object | string;\n\ntype XHRInterceptor = {\n  requestSent(id: number, url: string, method: string, headers: Object): void,\n  responseReceived(\n    id: number,\n    url: string,\n    status: number,\n    headers: Object,\n  ): void,\n  dataReceived(id: number, data: string): void,\n  loadingFinished(id: number, encodedDataLength: number): void,\n  loadingFailed(id: number, error: string): void,\n  ...\n};\n\n// The native blob module is optional so inject it here if available.\nif (BlobManager.isAvailable) {\n  BlobManager.addNetworkingHandler();\n}\n\nconst UNSENT = 0;\nconst OPENED = 1;\nconst HEADERS_RECEIVED = 2;\nconst LOADING = 3;\nconst DONE = 4;\n\nconst SUPPORTED_RESPONSE_TYPES = {\n  arraybuffer: typeof global.ArrayBuffer === 'function',\n  blob: typeof global.Blob === 'function',\n  document: false,\n  json: true,\n  text: true,\n  '': true,\n};\n\nconst REQUEST_EVENTS = [\n  'abort',\n  'error',\n  'load',\n  'loadstart',\n  'progress',\n  'timeout',\n  'loadend',\n];\n\nconst XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');\n\nclass XMLHttpRequestEventTarget extends (EventTarget(...REQUEST_EVENTS): any) {\n  onload: ?Function;\n  onloadstart: ?Function;\n  onprogress: ?Function;\n  ontimeout: ?Function;\n  onerror: ?Function;\n  onabort: ?Function;\n  onloadend: ?Function;\n}\n\n/**\n * Shared base for platform-specific XMLHttpRequest implementations.\n */\nclass XMLHttpRequest extends (EventTarget(...XHR_EVENTS): any) {\n  static UNSENT: number = UNSENT;\n  static OPENED: number = OPENED;\n  static HEADERS_RECEIVED: number = HEADERS_RECEIVED;\n  static LOADING: number = LOADING;\n  static DONE: number = DONE;\n\n  static _interceptor: ?XHRInterceptor = null;\n\n  UNSENT: number = UNSENT;\n  OPENED: number = OPENED;\n  HEADERS_RECEIVED: number = HEADERS_RECEIVED;\n  LOADING: number = LOADING;\n  DONE: number = DONE;\n\n  // EventTarget automatically initializes these to `null`.\n  onload: ?Function;\n  onloadstart: ?Function;\n  onprogress: ?Function;\n  ontimeout: ?Function;\n  onerror: ?Function;\n  onabort: ?Function;\n  onloadend: ?Function;\n  onreadystatechange: ?Function;\n\n  readyState: number = UNSENT;\n  responseHeaders: ?Object;\n  status: number = 0;\n  timeout: number = 0;\n  responseURL: ?string;\n  withCredentials: boolean = true;\n\n  upload: XMLHttpRequestEventTarget = new XMLHttpRequestEventTarget();\n\n  _requestId: ?number;\n  _subscriptions: Array<*>;\n\n  _aborted: boolean = false;\n  _cachedResponse: Response;\n  _hasError: boolean = false;\n  _headers: Object;\n  _lowerCaseResponseHeaders: Object;\n  _method: ?string = null;\n  _perfKey: ?string = null;\n  _response: string | ?Object;\n  _responseType: ResponseType;\n  _response: string = '';\n  _sent: boolean;\n  _url: ?string = null;\n  _timedOut: boolean = false;\n  _trackingName: string = 'unknown';\n  _incrementalEvents: boolean = false;\n  _performanceLogger: IPerformanceLogger = GlobalPerformanceLogger;\n\n  static setInterceptor(interceptor: ?XHRInterceptor) {\n    XMLHttpRequest._interceptor = interceptor;\n  }\n\n  constructor() {\n    super();\n    this._reset();\n  }\n\n  _reset(): void {\n    this.readyState = this.UNSENT;\n    this.responseHeaders = undefined;\n    this.status = 0;\n    delete this.responseURL;\n\n    this._requestId = null;\n\n    this._cachedResponse = undefined;\n    this._hasError = false;\n    this._headers = {};\n    this._response = '';\n    this._responseType = '';\n    this._sent = false;\n    this._lowerCaseResponseHeaders = {};\n\n    this._clearSubscriptions();\n    this._timedOut = false;\n  }\n\n  get responseType(): ResponseType {\n    return this._responseType;\n  }\n\n  set responseType(responseType: ResponseType): void {\n    if (this._sent) {\n      throw new Error(\n        \"Failed to set the 'responseType' property on 'XMLHttpRequest': The \" +\n          'response type cannot be set after the request has been sent.',\n      );\n    }\n    if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {\n      console.warn(\n        `The provided value '${responseType}' is not a valid 'responseType'.`,\n      );\n      return;\n    }\n\n    // redboxes early, e.g. for 'arraybuffer' on ios 7\n    invariant(\n      SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document',\n      `The provided value '${responseType}' is unsupported in this environment.`,\n    );\n\n    if (responseType === 'blob') {\n      invariant(\n        BlobManager.isAvailable,\n        'Native module BlobModule is required for blob support',\n      );\n    }\n    this._responseType = responseType;\n  }\n\n  get responseText(): string {\n    if (this._responseType !== '' && this._responseType !== 'text') {\n      throw new Error(\n        \"The 'responseText' property is only available if 'responseType' \" +\n          `is set to '' or 'text', but it is '${this._responseType}'.`,\n      );\n    }\n    if (this.readyState < LOADING) {\n      return '';\n    }\n    return this._response;\n  }\n\n  get response(): Response {\n    const {responseType} = this;\n    if (responseType === '' || responseType === 'text') {\n      return this.readyState < LOADING || this._hasError ? '' : this._response;\n    }\n\n    if (this.readyState !== DONE) {\n      return null;\n    }\n\n    if (this._cachedResponse !== undefined) {\n      return this._cachedResponse;\n    }\n\n    switch (responseType) {\n      case 'document':\n        this._cachedResponse = null;\n        break;\n\n      case 'arraybuffer':\n        this._cachedResponse = base64.toByteArray(this._response).buffer;\n        break;\n\n      case 'blob':\n        if (typeof this._response === 'object' && this._response) {\n          this._cachedResponse = BlobManager.createFromOptions(this._response);\n        } else if (this._response === '') {\n          this._cachedResponse = BlobManager.createFromParts([]);\n        } else {\n          throw new Error(`Invalid response for blob: ${this._response}`);\n        }\n        break;\n\n      case 'json':\n        try {\n          this._cachedResponse = JSON.parse(this._response);\n        } catch (_) {\n          this._cachedResponse = null;\n        }\n        break;\n\n      default:\n        this._cachedResponse = null;\n    }\n\n    return this._cachedResponse;\n  }\n\n  // exposed for testing\n  __didCreateRequest(requestId: number): void {\n    this._requestId = requestId;\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.requestSent(\n        requestId,\n        this._url || '',\n        this._method || 'GET',\n        this._headers,\n      );\n  }\n\n  // exposed for testing\n  __didUploadProgress(\n    requestId: number,\n    progress: number,\n    total: number,\n  ): void {\n    if (requestId === this._requestId) {\n      this.upload.dispatchEvent({\n        type: 'progress',\n        lengthComputable: true,\n        loaded: progress,\n        total,\n      });\n    }\n  }\n\n  __didReceiveResponse(\n    requestId: number,\n    status: number,\n    responseHeaders: ?Object,\n    responseURL: ?string,\n  ): void {\n    if (requestId === this._requestId) {\n      this._perfKey != null &&\n        this._performanceLogger.stopTimespan(this._perfKey);\n      this.status = status;\n      this.setResponseHeaders(responseHeaders);\n      this.setReadyState(this.HEADERS_RECEIVED);\n      if (responseURL || responseURL === '') {\n        this.responseURL = responseURL;\n      } else {\n        delete this.responseURL;\n      }\n\n      XMLHttpRequest._interceptor &&\n        XMLHttpRequest._interceptor.responseReceived(\n          requestId,\n          responseURL || this._url || '',\n          status,\n          responseHeaders || {},\n        );\n    }\n  }\n\n  __didReceiveData(requestId: number, response: string): void {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this._response = response;\n    this._cachedResponse = undefined; // force lazy recomputation\n    this.setReadyState(this.LOADING);\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.dataReceived(requestId, response);\n  }\n\n  __didReceiveIncrementalData(\n    requestId: number,\n    responseText: string,\n    progress: number,\n    total: number,\n  ) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    if (!this._response) {\n      this._response = responseText;\n    } else {\n      this._response += responseText;\n    }\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.dataReceived(requestId, responseText);\n\n    this.setReadyState(this.LOADING);\n    this.__didReceiveDataProgress(requestId, progress, total);\n  }\n\n  __didReceiveDataProgress(\n    requestId: number,\n    loaded: number,\n    total: number,\n  ): void {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this.dispatchEvent({\n      type: 'progress',\n      lengthComputable: total >= 0,\n      loaded,\n      total,\n    });\n  }\n\n  // exposed for testing\n  __didCompleteResponse(\n    requestId: number,\n    error: string,\n    timeOutError: boolean,\n  ): void {\n    if (requestId === this._requestId) {\n      if (error) {\n        if (this._responseType === '' || this._responseType === 'text') {\n          this._response = error;\n        }\n        this._hasError = true;\n        if (timeOutError) {\n          this._timedOut = true;\n        }\n      }\n      this._clearSubscriptions();\n      this._requestId = null;\n      this.setReadyState(this.DONE);\n\n      if (error) {\n        XMLHttpRequest._interceptor &&\n          XMLHttpRequest._interceptor.loadingFailed(requestId, error);\n      } else {\n        XMLHttpRequest._interceptor &&\n          XMLHttpRequest._interceptor.loadingFinished(\n            requestId,\n            this._response.length,\n          );\n      }\n    }\n  }\n\n  _clearSubscriptions(): void {\n    (this._subscriptions || []).forEach(sub => {\n      if (sub) {\n        sub.remove();\n      }\n    });\n    this._subscriptions = [];\n  }\n\n  getAllResponseHeaders(): ?string {\n    if (!this.responseHeaders) {\n      // according to the spec, return null if no response has been received\n      return null;\n    }\n    const headers = this.responseHeaders || {};\n    return Object.keys(headers)\n      .map(headerName => {\n        return headerName + ': ' + headers[headerName];\n      })\n      .join('\\r\\n');\n  }\n\n  getResponseHeader(header: string): ?string {\n    const value = this._lowerCaseResponseHeaders[header.toLowerCase()];\n    return value !== undefined ? value : null;\n  }\n\n  setRequestHeader(header: string, value: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    this._headers[header.toLowerCase()] = String(value);\n  }\n\n  /**\n   * Custom extension for tracking origins of request.\n   */\n  setTrackingName(trackingName: string): XMLHttpRequest {\n    this._trackingName = trackingName;\n    return this;\n  }\n\n  /**\n   * Custom extension for setting a custom performance logger\n   */\n  setPerformanceLogger(performanceLogger: IPerformanceLogger): XMLHttpRequest {\n    this._performanceLogger = performanceLogger;\n    return this;\n  }\n\n  open(method: string, url: string, async: ?boolean): void {\n    /* Other optional arguments are not supported yet */\n    if (this.readyState !== this.UNSENT) {\n      throw new Error('Cannot open, already sending');\n    }\n    if (async !== undefined && !async) {\n      // async is default\n      throw new Error('Synchronous http requests are not supported');\n    }\n    if (!url) {\n      throw new Error('Cannot load an empty url');\n    }\n    this._method = method.toUpperCase();\n    this._url = url;\n    this._aborted = false;\n    this.setReadyState(this.OPENED);\n  }\n\n  send(data: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    if (this._sent) {\n      throw new Error('Request has already been sent');\n    }\n    this._sent = true;\n    const incrementalEvents =\n      this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;\n\n    this._subscriptions.push(\n      RCTNetworking.addListener('didSendNetworkData', args =>\n        this.__didUploadProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkResponse', args =>\n        this.__didReceiveResponse(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkData', args =>\n        this.__didReceiveData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkIncrementalData', args =>\n        this.__didReceiveIncrementalData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkDataProgress', args =>\n        this.__didReceiveDataProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didCompleteNetworkResponse', args =>\n        this.__didCompleteResponse(...args),\n      ),\n    );\n\n    let nativeResponseType: NativeResponseType = 'text';\n    if (this._responseType === 'arraybuffer') {\n      nativeResponseType = 'base64';\n    }\n    if (this._responseType === 'blob') {\n      nativeResponseType = 'blob';\n    }\n\n    const doSend = () => {\n      const friendlyName =\n        this._trackingName !== 'unknown' ? this._trackingName : this._url;\n      this._perfKey = 'network_XMLHttpRequest_' + String(friendlyName);\n      this._performanceLogger.startTimespan(this._perfKey);\n      invariant(\n        this._method,\n        'XMLHttpRequest method needs to be defined (%s).',\n        friendlyName,\n      );\n      invariant(\n        this._url,\n        'XMLHttpRequest URL needs to be defined (%s).',\n        friendlyName,\n      );\n      RCTNetworking.sendRequest(\n        this._method,\n        this._trackingName,\n        this._url,\n        this._headers,\n        data,\n        /* $FlowFixMe(>=0.78.0 site=react_native_android_fb) This issue was found\n         * when making Flow check .android.js files. */\n        nativeResponseType,\n        incrementalEvents,\n        this.timeout,\n        this.__didCreateRequest.bind(this),\n        this.withCredentials,\n      );\n    };\n    if (DEBUG_NETWORK_SEND_DELAY) {\n      setTimeout(doSend, DEBUG_NETWORK_SEND_DELAY);\n    } else {\n      doSend();\n    }\n  }\n\n  abort(): void {\n    this._aborted = true;\n    if (this._requestId) {\n      RCTNetworking.abortRequest(this._requestId);\n    }\n    // only call onreadystatechange if there is something to abort,\n    // below logic is per spec\n    if (\n      !(\n        this.readyState === this.UNSENT ||\n        (this.readyState === this.OPENED && !this._sent) ||\n        this.readyState === this.DONE\n      )\n    ) {\n      this._reset();\n      this.setReadyState(this.DONE);\n    }\n    // Reset again after, in case modified in handler\n    this._reset();\n  }\n\n  setResponseHeaders(responseHeaders: ?Object): void {\n    this.responseHeaders = responseHeaders || null;\n    const headers = responseHeaders || {};\n    this._lowerCaseResponseHeaders = Object.keys(headers).reduce(\n      (lcaseHeaders, headerName) => {\n        lcaseHeaders[headerName.toLowerCase()] = headers[headerName];\n        return lcaseHeaders;\n      },\n      {},\n    );\n  }\n\n  setReadyState(newState: number): void {\n    this.readyState = newState;\n    this.dispatchEvent({type: 'readystatechange'});\n    if (newState === this.DONE) {\n      if (this._aborted) {\n        this.dispatchEvent({type: 'abort'});\n      } else if (this._hasError) {\n        if (this._timedOut) {\n          this.dispatchEvent({type: 'timeout'});\n        } else {\n          this.dispatchEvent({type: 'error'});\n        }\n      } else {\n        this.dispatchEvent({type: 'load'});\n      }\n      this.dispatchEvent({type: 'loadend'});\n    }\n  }\n\n  /* global EventListener */\n  addEventListener(type: string, listener: EventListener): void {\n    // If we dont' have a 'readystatechange' event handler, we don't\n    // have to send repeated LOADING events with incremental updates\n    // to responseText, which will avoid a bunch of native -> JS\n    // bridge traffic.\n    if (type === 'readystatechange' || type === 'progress') {\n      this._incrementalEvents = true;\n    }\n    super.addEventListener(type, listener);\n  }\n}\n\nmodule.exports = XMLHttpRequest;\n"]},"metadata":{},"sourceType":"script"}